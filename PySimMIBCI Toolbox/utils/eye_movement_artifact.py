#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Apr 15 10:18:01 2021

@author: catalinamgalvan
"""

import numpy as np
from numpy import einsum
from mne._ola import _Interp2
from mne.io import BaseRaw
from mne.io.pick import pick_types
from mne.bem import fit_sphere_to_headshape, make_sphere_model
from mne.source_space import setup_volume_source_space
from mne.utils import check_random_state, _validate_type, _check_preload
from mne.simulation.raw import _check_head_pos, _SimForwards


def add_eye_movement(raw, head_pos=None, interp='cos2', n_jobs=1,
                     random_state=None, verbose=None):
    """Add eye-movement artifact to raw data.

    Parameters
    ----------
    raw : instance of Raw
        The raw instance to modify.
    %(head_pos)s
    %(interp)s
    %(n_jobs)s
    %(random_state)s
        The random generator state used for noise
        randomization.
    %(verbose)s

    Returns
    -------
    raw : instance of Raw
        The instance, modified in place.

    Notes
    -----
    The eye-movements artifacts are generated by:
    1. Random activation times are drawn from an homogeneous poisson
       process.
    2. In each activation, the eye-movement is generated as random noise with
       maximum random duration of 500 ms.
    3. Two activated dipoles are located in the z=0 plane (in head
       coordinates) at Â±30 degrees away from the y axis (nasion).
    4. Activations affect MEG and EEG channels.

    The scale-factor of the activation function was chosen based on
    visual inspection to yield amplitudes generally consistent with those
    seen in experimental data.
    """
    return add_exg(raw, 'eye_movement', head_pos, interp, n_jobs,
                   random_state)


def add_exg(raw, kind, head_pos, interp, n_jobs, random_state):
    assert isinstance(kind, str) and kind in ('ecg', 'blink', 'eye_movement')
    _validate_type(raw, BaseRaw, 'raw')
    _check_preload(raw, 'Adding %s noise ' % (kind,))
    rng = check_random_state(random_state)
    info, times, first_samp = raw.info, raw.times, raw.first_samp
    data = raw._data
    meg_picks = pick_types(info, meg=True, eeg=False, exclude=())
    meeg_picks = pick_types(info, meg=True, eeg=True, exclude=())
    R, r0 = fit_sphere_to_headshape(info, units='m', verbose=False)[:2]
    bem = make_sphere_model(r0, head_radius=R,
                            relative_radii=(0.97, 0.98, 0.99, 1.),
                            sigmas=(0.33, 1.0, 0.004, 0.33), verbose=False)
    trans = None
    dev_head_ts, offsets = _check_head_pos(head_pos, info, first_samp, times)
    if kind == 'eye_movement':
        # place dipoles at 45 degree angles in z=0 plane
        exg_rr = np.array([[np.cos(np.pi / 3.), np.sin(np.pi / 3.), 0.],
                           [-np.cos(np.pi / 3.), np.sin(np.pi / 3), 0.]])
        exg_rr /= np.sqrt(np.sum(exg_rr * exg_rr, axis=1, keepdims=True))
        exg_rr *= 0.96 * R
        exg_rr += r0
        # oriented upward
        nn = np.array([[0., 0., 1.], [0., 0., 1.]])
        # Draw occurence times from a Poisson process
        timeNow = 0
        endTime = times[-1]
        eventFreq = 0.2
        randomMaxduration = 500  # in ms
        timeline = np.zeros(np.size(times))
        while timeNow < endTime:
            nextTime = timeNow + (-np.log(1-rng.uniform()))/eventFreq
            if nextTime < endTime:
                event_latency = np.int(nextTime*info['sfreq'])
                event_duration = np.int(np.random.uniform() * randomMaxduration
                                        / 1000 * info['sfreq'])
                timeline[event_latency:event_latency+event_duration] = 1
            timeNow = nextTime
        exg_data = np.random.randn(np.size(times)) * timeline[np.newaxis,
                                                              :] * 1e-8
        picks = meeg_picks
    del meg_picks, meeg_picks
    src = setup_volume_source_space(pos=dict(rr=exg_rr, nn=nn),
                                    sphere_units='mm')

    used = np.zeros(len(raw.times), bool)
    get_fwd = _SimForwards(
        dev_head_ts, offsets, info, trans, src, bem, 0.005, n_jobs, picks)
    interper = _Interp2(offsets, get_fwd, interp)
    proc_lims = np.concatenate([np.arange(0, len(used), 10000), [len(used)]])
    for start, stop in zip(proc_lims[:-1], proc_lims[1:]):
        fwd, _ = interper.feed(stop - start)
        data[picks, start:stop] += einsum(
            'svt,vt->st', fwd, exg_data[:, start:stop])
        assert not used[start:stop].any()
        used[start:stop] = True
    assert used.all()
